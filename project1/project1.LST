C51 COMPILER V9.06   PROJECT1                                                              03/16/2017 23:51:46 PAGE 1   


C51 COMPILER V9.06, COMPILATION OF MODULE PROJECT1
OBJECT MODULE PLACED IN project1.OBJ
COMPILER INVOKED BY: D:\Keil uV5\C51\BIN\C51.EXE project1.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include <reg52.h>
   2          #include <intrins.h>
   3          
   4          typedef unsigned char uchar;
   5          typedef unsigned int uint;
   6          
   7          uchar code Number[] = {'0','1','2','3','4','5','6','7','8','9'};
   8          uchar Tem[] = {0,0,'.',0,0xA1,0xE6};
   9          uchar code TAB[] = "状态：";
  10          uchar code TAB1[] = "正常    ";
  11          uchar code TAB2[] = "有害气体";
  12          uchar code TAB3[] = "温度过高";
  13          uchar code TAB4[] = "温度：";
  14          
  15          bit C4H10_Flag = 0;
  16          bit OC_Flag = 0;
  17          
  18          uchar code PHOTO[] = {
  19          0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  20          0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  21          0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  22          0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  23          0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  24          0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  25          0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  26          0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  27          0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  28          0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  29          0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  30          0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  31          0x00,0x00,0x00,0x00,0x00,0x0F,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  32          0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  33          0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  34          0x00,0x00,0x00,0x00,0x03,0xFF,0xFF,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  35          0x00,0x00,0x00,0x00,0x07,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  36          0x00,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
  37          0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,
  38          0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xFF,0xFF,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,
  39          0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xFF,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,
  40          0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xFF,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,
  41          0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,
  42          0x00,0x00,0x00,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,
  43          0x00,0x00,0x00,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,
  44          0x00,0x00,0x00,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,
  45          0x00,0x00,0x00,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,
  46          0x00,0x00,0x00,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,
  47          0x00,0x00,0x00,0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,
  48          0x00,0x00,0x00,0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,
  49          0x00,0x00,0x00,0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,
  50          0x00,0x00,0x00,0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,
  51          0x00,0x00,0x00,0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,
  52          0x00,0x00,0x00,0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,
  53          0x00,0x00,0x00,0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,
  54          0x00,0x00,0x00,0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,
  55          0x00,0x00,0x00,0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,
C51 COMPILER V9.06   PROJECT1                                                              03/16/2017 23:51:46 PAGE 2   

  56          0x00,0x00,0x00,0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF0,0x00,0x00,0x00,0x00,
  57          0x00,0x00,0x00,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xE0,0x00,0x00,0x00,0x00,
  58          0x00,0x00,0x00,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,
  59          0x00,0x00,0x00,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,
  60          0x00,0x00,0x00,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,
  61          0x00,0x00,0x00,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,
  62          0x00,0x00,0x00,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xE0,0x00,0x00,0x00,0x00,0x00,
  63          0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,
  64          0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,
  65          0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xFF,0xFF,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,
  66          0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xFF,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,
  67          0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xFF,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,
  68          0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,
  69          0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,
  70          0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,
  71          0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xFF,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,
  72          0x00,0x00,0x00,0x00,0x7F,0xFF,0xFF,0xFF,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,
  73          0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0xFF,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,
  74          0x00,0x00,0x00,0x00,0x1F,0xFF,0xFF,0xFF,0xFF,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,
  75          0x00,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
  76          0x00,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  77          0x00,0x00,0x00,0x00,0x07,0xFF,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  78          0x00,0x00,0x00,0x00,0x03,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  79          0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  80          0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  81          0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  82          0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
  83          };
  84          #define COM 0xF8      
  85          #define DAT 0xFA
  86          // LCD12864液晶位
  87          sbit CS  = P1^3;  // 串行片选
  88          sbit SID = P1^2;  // 串行数据
  89          sbit CLK = P1^1;  // 串行时钟
  90          // DS18B20温度传感器
  91          sbit DQ = P1^0;   // DS18B20 数据总线
  92          sbit LED = P1^6;
  93          // MQ-2
  94          sbit Waring = P3^2;
  95          // 函数声明
  96          void delay(uint us);          // 2us延时函数
  97          void DelayMs(uint ms);        // ms延时函数
  98          
  99          void DS18B20_Init();
 100          void compute(uchar lsb,uchar msb);    // 温度计算
 101          uchar DS18B20_Read();
 102          void DS18B20_Write(uchar udata);
 103          
 104          void LCD12864_Init();
 105          void LCD_Write_Byte(uchar dat);     // LCD写字节
 106          void LCD_Write_Dat(uchar dat);
 107          void LCD_Write_Com(uchar com);
 108          void LCD_XY(uchar x,y);
 109          void Photo(uchar *pPic);        // LCD写图片
 110          
 111          /*第一字节：串口控制―格式 11111ABC
 112          A 为数据传送方向控制：H 表示数据从 LCD 到 MCU，L 表示数据从 MCU 到 LCD
 113          B 为数据类型选择：H 表示数据是显示数据，L 表示数据是控制指令
 114          C 固定为 0
 115          */
 116          
 117          //  LCD写数据函数
C51 COMPILER V9.06   PROJECT1                                                              03/16/2017 23:51:46 PAGE 3   

 118          void LCD_Write_Com(uchar com)
 119          {
 120   1        uchar MSB,LSB;
 121   1        MSB = (com & 0xF0);
 122   1        LSB = (com <<= 4);
 123   1        LCD_Write_Byte(COM);    // 写入指令
 124   1        LCD_Write_Byte(MSB);    // 写入指令高8位
 125   1        LCD_Write_Byte(LSB);    // 写入指令低8位
 126   1      }
 127          
 128          //  LCD写指令函数
 129          void LCD_Write_Dat(uchar dat)
 130          {
 131   1        uchar MSB,LSB;
 132   1        MSB = (dat & 0xF0);
 133   1        LSB = (dat <<= 4);
 134   1        LCD_Write_Byte(DAT);    // 写入数据
 135   1        LCD_Write_Byte(MSB);    // 写入数据高8位
 136   1        LCD_Write_Byte(LSB);    // 写入数据低8位
 137   1      }
 138          
 139          //  LCD写入一字节
 140          void LCD_Write_Byte(uchar dat)
 141          {
 142   1        uchar i;
 143   1        for(i = 0; i < 8; i++)
 144   1        {
 145   2          CLK = 0;
 146   2          if(dat & 0x80)
 147   2            SID = 1;
 148   2          else
 149   2            SID = 0;
 150   2          CLK = 1;
 151   2          dat <<= 1;
 152   2        }
 153   1      }
 154          void LCD_Display(uchar x,uchar y,uchar *pDisplayData)
 155          {
 156   1        LCD_XY(x,y);
 157   1        while(*pDisplayData != '\0')
 158   1          LCD_Write_Dat(*pDisplayData++);
 159   1      }
 160          
 161          void LCD_XY(uchar x,y)
 162          {
 163   1        uchar uX,XY;
 164   1        if(1 == x)
 165   1          uX = 0x80;    // 第一行
 166   1        else if(2 == x)
 167   1          uX = 0x90;    // 第二行
 168   1        else if(3 == x)
 169   1          uX = 0x88;    // 第三行
 170   1        else if(4 == x)   
 171   1          uX = 0x98;    // 第四行
 172   1        XY = uX+y;
 173   1        LCD_Write_Com(XY);
 174   1      }
 175          
 176          void LCD12864_Init()
 177          {
 178   1        CS = 1;   
 179   1        LCD_Write_Com(0x30);    // 功能设置：基本指令
C51 COMPILER V9.06   PROJECT1                                                              03/16/2017 23:51:46 PAGE 4   

 180   1        DelayMs(10);
 181   1        LCD_Write_Com(0x01);    // 清屏
 182   1        DelayMs(10);
 183   1        LCD_Write_Com(0x0C);    // 显示状态：开显示，游标关闭
 184   1        DelayMs(10);  
 185   1      }
 186          
 187          //  11.0592Mhz 约1ms延时
 188          void DelayMs(uint ms)
 189          {
 190   1        uchar i,j;
 191   1        while(ms--)
 192   1        {
 193   2          for(i = 0; i < 9; i++)
 194   2            for(j = 0; j < 177; j++);
 195   2        } 
 196   1      }
 197          // 11.0592Mhz 约2us延时
 198          void delay(uint us)   
 199          { 
 200   1        uint i;
 201   1        for(i = 0; i < us; i++)
 202   1          _nop_();
 203   1      }
 204          
 205          
 206          void Photo(uchar *pPic)
 207          {
 208   1        uchar i,j;
 209   1        LCD_Write_Com(0x34);    // 扩充指令，关绘图显示
 210   1        // 先写上半屏
 211   1        for(i = 0; i < 32; i++)
 212   1        {
 213   2          LCD_Write_Com(0x80 + i);  // 写水平坐标
 214   2          LCD_Write_Com(0x80);    // 写垂直坐标   
 215   2          for(j = 0; j < 16; j++)
 216   2          {
 217   3            LCD_Write_Dat(*pPic++); 
 218   3          }
 219   2        }
 220   1        // 再写下半屏
 221   1        for(i = 0; i < 32; i++)
 222   1        {
 223   2          LCD_Write_Com(0x80 + i);  // 写水平坐标
 224   2          LCD_Write_Com(0x88);    // 写垂直坐标   
 225   2          for(j = 0; j < 16; j++)
 226   2          {
 227   3            LCD_Write_Dat(*pPic++); 
 228   3          }
 229   2        }
 230   1        LCD_Write_Com(0x36);    // 扩充指令，开绘图显示
 231   1      }
 232          
 233          void DS18B20_Write(uchar udata)
 234          {
 235   1        uchar i;
 236   1        uchar dat;
 237   1        for(i = 0; i < 8; i++)
 238   1        {
 239   2          dat = udata & 0x01;
 240   2          udata = udata >> 1;   // udata右移一位准备下一次送上总线
 241   2          if(dat)
C51 COMPILER V9.06   PROJECT1                                                              03/16/2017 23:51:46 PAGE 5   

 242   2          {
 243   3            DQ = 0;   // 拉低总线
 244   3            delay(1); // 延时2us
 245   3            DQ = 1;   // 送1
 246   3            delay(40);  // 延时80us
 247   3            DQ = 1;   // 释放总线
 248   3            delay(1); // 延时2us
 249   3          }
 250   2          else
 251   2          {
 252   3            DQ = 0;   // 拉低总线
 253   3            delay(1); // 延时2us
 254   3            DQ = 0;   // 送0
 255   3            delay(40);  // 延时80us;
 256   3            DQ = 1;   // 释放总线
 257   3            delay(1); // 延时2us;
 258   3          }
 259   2        } 
 260   1      }
 261          
 262          uchar DS18B20_Read()
 263          {
 264   1        uchar i;
 265   1        uchar udata = 0x00;
 266   1        for(i = 0; i < 8; i++)
 267   1        {
 268   2          udata = udata >> 1; // udata右移一位，第一次移位为空操作
 269   2          DQ = 0;     // 拉低总线
 270   2          delay(2);   // 延时4us，产生读时隙
 271   2          DQ = 1;     // 拉高总线
 272   2          if(DQ)
 273   2            udata |= 0x80;    // 1：读DQ数据并存放在udata最高位
 274   2          else
 275   2            udata |= 0x00;    // 0：读DQ数据并存放在udata最高位
 276   2          delay(40);    // 延时80us
 277   2          DQ = 1;     // 释放总线
 278   2          delay(1);   // 延时2us
 279   2        }
 280   1        return(udata);  
 281   1      }
 282          
 283          void DS18B20_Init()
 284          {
 285   1        DQ = 1;     // 拉高总线
 286   1        delay(1);
 287   1        
 288   1        DQ = 0;     // 拉低总线
 289   1        delay(350);   // 延时700us  
 290   1        DQ = 1;     // 释放总线
 291   1        delay(15);    // 延时30us
 292   1        while(DQ);    // 等待DS18B20拉低总线
 293   1          //LED = 0;  // 复位成功，点亮LED
 294   1        delay(100);   // 延时200us
 295   1        DQ = 1;     // 释放总线
 296   1        delay(150);   // 延时300us
 297   1      }
 298          
 299          void compute(uchar lsb,uchar msb)
 300          {
 301   1        uchar ge,shi,bai;
 302   1        uint num;
 303   1        uint temp;
C51 COMPILER V9.06   PROJECT1                                                              03/16/2017 23:51:46 PAGE 6   

 304   1        num = msb;
 305   1        num  <<= 8;
 306   1        num |= lsb;
 307   1        temp = num*0.0625*10+0.5; 
 308   1        bai = temp/100;   
 309   1        shi = temp%100/10;  
 310   1        ge  = temp%100%10;  
 311   1        Tem[0] = bai;
 312   1        Tem[1] = shi;
 313   1        Tem[3] = ge;
 314   1        Tem[0] = Number[Tem[0]];
 315   1        Tem[1] = Number[Tem[1]];
 316   1        Tem[3] = Number[Tem[3]];
 317   1      }
 318          
 319          void Uart_ISR() interrupt 4
 320          {
 321   1        uchar temp;
 322   1      //  uchar *pChar;
 323   1        uchar i;
 324   1        if(RI)
 325   1        {
 326   2          RI = 0;
 327   2          temp = SBUF;
 328   2        }
 329   1        if(temp == '1')
 330   1        {
 331   2          for(i = 0; i < 4; i++)
 332   2          {
 333   3            SBUF = Tem[i];
 334   3            while(!TI);
 335   3            TI = 0;
 336   3          }
 337   2          SBUF = '\n';
 338   2          while(!TI);
 339   2          TI = 0;
 340   2          temp = 0;
 341   2        }
 342   1      //  else if(temp == '2')
 343   1      //  {
 344   1      //    *pChar = TAB;
 345   1      //    if(!C4H10_Flag && !OC_Flag)    // 正常
 346   1      //    {
 347   1      //      for(i = 0; i < 8; i++)
 348   1      //      {
 349   1      //        SBUF = *pChar++;
 350   1      //        while(!TI);
 351   1      //        TI = 0;
 352   1      //      }
 353   1      //      SBUF = '\n';
 354   1      //      while(!TI);
 355   1      //      TI = 0;
 356   1      //      temp = 0; 
 357   1      //    }
 358   1      //    else if(C4H10_Flag && OC_Flag)
 359   1      //    {
 360   1      //      // 温度，气体同时报警
 361   1      //    }
 362   1      //    else if(C4H10_Flag)
 363   1      //    {
 364   1      //      // 有害气体
 365   1      //    }
C51 COMPILER V9.06   PROJECT1                                                              03/16/2017 23:51:46 PAGE 7   

 366   1      //    else if(OC_Flag)
 367   1      //    {
 368   1      //      // 温度过高
 369   1      //    }   
 370   1      }
 371          
 372          /*  11.0592Mhz  Uart串口初始化        */
 373          void Uart_Init()  // 串口初始化
 374          {
 375   1        TMOD &= 0x0F; // 保留后定时器0设置，清空定时器1设置
 376   1        TMOD |= 0x20; // 定时器1 模式2
 377   1        SCON |= 0x50; // 串口方式1，8位UART波特率可变，可接收
 378   1        TH1   = 0xFD; // TL1溢出后将TH1的值装入
 379   1        TL1   = 0xFD; // 9600bps
 380   1        ET1   = 0;    // 关闭定时器1中断
 381   1        ES    = 1;
 382   1        TR1   = 1;    // 开定时器1
 383   1      }
 384          /**********************************/
 385          void Timer0_ISR() interrupt 1
 386          {
 387   1        TL0 = 0x00;     // 设置定时初值   10ms
 388   1        TH0 = 0xDC;     // 设置定时重载值
 389   1        if(!Waring)
 390   1          C4H10_Flag = 1; // 有害气体标识
 391   1        else
 392   1          C4H10_Flag = 0;
 393   1              
 394   1        if(Tem[0] != '2' && Tem[0] != '1' && Tem[0] != '0'  )
 395   1          OC_Flag = 1;    // 温度过高
 396   1        else
 397   1          OC_Flag = 0;  
 398   1      }
 399          
 400          void Timer0_Init()
 401          {
 402   1        TMOD &= 0xF0;   // 设置定时器模式
 403   1        TMOD |= 0x02;   // 设置定时器模式
 404   1        TL0 = 0x00;     // 设置定时初值   10ms
 405   1        TH0 = 0xDC;     // 设置定时重载值
 406   1        TF0 = 0;      // 清除TF0标志
 407   1        ET0 = 1;      // 定时器0 允许中断
 408   1        EA  = 1;
 409   1        TR0 = 1;
 410   1      }
 411          
 412          void main()
 413          {
 414   1        DelayMs(10);      
 415   1        Uart_Init();      // 串口初始化
 416   1        LCD12864_Init();    // LCD12864初始化 
 417   1        Photo(PHOTO);
 418   1        DelayMs(800);     // 图片显示时间
 419   1        LCD_Write_Com(0x34);  // 扩充指令、关闭绘图显
 420   1        LCD12864_Init();
 421   1        LCD_Display(1,0,TAB);   // 第一行。一列  状胎：
 422   1        LCD_Display(4,2,TAB4);    // 第四行，三列  温度：
 423   1        while(1)
 424   1        {
 425   2          // 初始化并启动温度转换
 426   2          DS18B20_Init();     // DS18B20初始化
 427   2          DS18B20_Write(0xCC);  // 跳过ROM地址
C51 COMPILER V9.06   PROJECT1                                                              03/16/2017 23:51:46 PAGE 8   

 428   2          DS18B20_Write(0x44);  // 启动温度转换
 429   2          DelayMs(1000);
 430   2          // 初始化，读温度
 431   2          DS18B20_Init();     // DS18B20初始化
 432   2          DS18B20_Write(0xCC);  // 跳过ROM地址
 433   2          DS18B20_Write(0xBE);  // 读取RAM命令
 434   2          compute(DS18B20_Read(),DS18B20_Read());   //  先读低8位，再读高八位
 435   2          Timer0_Init();      // 定时器0初始化
 436   2          if(C4H10_Flag)
 437   2            LCD_Display(1,3,TAB2);    // 有害气体
 438   2          else if(!OC_Flag && !C4H10_Flag)
 439   2            LCD_Display(1,3,TAB1);    // 正常
 440   2          if(OC_Flag)
 441   2            LCD_Display(1,3,TAB3);    // 温度过高
 442   2          else if(!OC_Flag && !C4H10_Flag)
 443   2            LCD_Display(1,3,TAB1);
 444   2              
 445   2          LCD_Display(4,5,Tem);   // 温度刷新：xx.xx℃        
 446   2        }
 447   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    972    ----
   CONSTANT SIZE    =   1075    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6      15
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
